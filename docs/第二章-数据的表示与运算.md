# 第二章 数据的表示与运算

> 本章对应课件：`计算机组成原理2.1.pdf`、`计算机组成原理2.2.pdf`

## 一、章节概述

本章深入研究计算机内部如何表示数值、字符等数据，以及如何执行基本算术运算。这是理解计算机工作原理的基础，也是后续学习CPU设计、ALU实现的关键前置知识。

## 二、学习目标（高亮速览）

1. <mark>掌握数制转换方法</mark>
   - 熟练掌握<mark>二进制/八进制/十进制/十六进制</mark>之间的转换
   - 理解为何计算机选用<mark>二进制</mark>系统

2. <mark>理解定点数表示</mark>
   - 掌握<mark>原码/反码/补码</mark>的表示规则与特性
   - 理解<mark>补码</mark>的设计思想及其在运算中的优势

3. <mark>理解浮点数表示</mark>
   - 掌握<mark>IEEE 754</mark>浮点数标准（单精度、双精度）
   - 理解<mark>规格化/阶码(E)/尾数(M)</mark>等概念
   - 掌握浮点数的运算方法及<mark>精度损失</mark>问题

4. <mark>掌握定点数运算</mark>
   - 能设计简单的加法器、减法器电路
   - 理解乘法器和除法器的基本实现方式
   - 掌握<mark>溢出</mark>检测方法

5. <mark>了解字符编码</mark>
   - 熟悉<mark>ASCII/Unicode</mark>等字符编码标准

## 三、核心内容详解

### 2.1 数据的表示

#### 1. 数制与转换

**常用数制**：
- <mark>二进制</mark>（Base-2）：逢二进一，使用数字0、1
- 八进制（Base-8）：使用数字0-7，常用于简化二进制表示
- 十进制（Base-10）：日常使用的数制
- <mark>十六进制</mark>（Base-16）：使用0-9、A-F，简洁表示二进制

**转换技巧**：
- 十进制→二进制：除2取余法（整数）、乘2取整法（小数）
- 二进制→十进制：按权展开法
- 二进制↔八进制/十六进制：分组转换法（3位/4位一组）

**示例**：
```
十进制 25 → 二进制：
25 ÷ 2 = 12 余 1
12 ÷ 2 = 6  余 0
6  ÷ 2 = 3  余 0
3  ÷ 2 = 1  余 1
1  ÷ 2 = 0  余 1
结果：11001 (从下往上读)
```

#### 2. 定点数表示

**机器数与真值**：
- <mark>机器数</mark>：数据在计算机中的二进制表示形式（包含<mark>符号位</mark>）
- <mark>真值</mark>：机器数对应的实际数值

**三种编码方式**：

| 编码 | 符号位规则 | 数值位规则 | 零的表示 | 特点 |
|------|------------|------------|----------|------|
| 原码 | 0正1负 | 绝对值的二进制 | +0和-0两种 | 直观但运算复杂 |
| 反码 | 0正1负 | 负数数值位取反 | +0和-0两种 | 过渡形式 |
| <mark>补码</mark> | 0正1负 | 负数反码+1 | 唯一的0 | 便于运算 |

**补码的优势**：
1. 加法和减法统一为<mark>加法运算</mark>
2. 零的表示唯一
3. 可以多表示一个负数（-2^(n-1)）

**示例**（8位机器数）：
```
+5: 原码 = 00000101, 反码 = 00000101, 补码 = 00000101
-5: 原码 = 10000101, 反码 = 11111010, 补码 = 11111011
```

#### 3. 浮点数表示（<mark>IEEE 754</mark>标准）

**格式**：
- <mark>符号位（S）</mark>：1位，0表示正，1表示负
- <mark>阶码（E）</mark>：8位（单精度）/11位（双精度），使用移码表示
- <mark>尾数（M）</mark>：23位（单精度）/52位（双精度），使用原码表示

**单精度浮点数（32位）**：
```
S | EEEEEEEE | MMMMMMMMMMMMMMMMMMMMMMM
1    8位         23位
```

**规格化**：
- 尾数隐藏最高位的<mark>1（隐含位）</mark>，即实际尾数为1.M
- 阶码采用<mark>偏置量</mark>表示（单精度偏移127，双精度偏移1023）

**示例**：表示-12.5
```
1. 转二进制：12.5 = 1100.1
2. 规格化：1100.1 = 1.1001 × 2³
3. 符号位：S = 1（负数）
4. 阶码：E = 3 + 127 = 130 = 10000010
5. 尾数：M = 1001... (隐藏了前导1)
结果：1 10000010 10010000000000000000000
```

**特殊值**：
- 0：阶码和尾数全为0
- ∞：阶码全1，尾数全0
- <mark>NaN</mark>：阶码全1，尾数非0

#### 4. 字符编码

- <mark>ASCII</mark>：7位编码，表示128个字符（包括控制字符和可打印字符）
- <mark>Unicode</mark>：支持全球所有语言字符
  - <mark>UTF-8</mark>：变长编码，兼容ASCII
  - UTF-16：使用2或4字节
  - UTF-32：固定4字节

### 2.2 定点数的运算

#### 1. 定点加减运算

**补码加法规则**：
- <mark>符号位</mark>与数值位一起参与运算
- 结果自动为<mark>补码</mark>形式
- <mark>溢出</mark>判断：双符号位法或参与最高位进位

**示例**：+5 + (-3)
```
[+5]补 = 00000101
[-3]补 = 11111101
相加   = 00000010 = +2 ✓
```

**减法转加法**：
- A - B = A + (-B)
- 即对B求<mark>补码</mark>（变号），然后与A相加

**溢出判断**：
- **方法1**：<mark>双符号位法</mark>（变形补码）
  - 00：正常正数
  - 11：正常负数
  - 01：负溢出
  - 10：正溢出

- **方法2**：<mark>单符号位法</mark>
  - 最高位进位C_n与符号位进位C_(n-1)异或
  - V = C_n ⊕ C_(n-1)

#### 2. 定点乘法运算

**原码一位乘法**：
- 符号位单独处理（<mark>异或</mark>得符号）
- 数值部分相乘
- 部分积累加

**补码乘法（<mark>Booth算法</mark>）**：
- 从低位到高位扫描乘数
- 根据相邻位差异决定操作（加、减或移位）
- 优点：正负数统一处理

#### 3. 定点除法运算

**原码除法（<mark>恢复余数法</mark>）**：
1. 比较除数与被除数/余数
2. 够减则商1，继续；不够减则商0，恢复余数

**补码除法（<mark>加减交替法</mark>）**：
- 利用补码性质，简化符号处理

#### 4. 算术逻辑单元（<mark>ALU</mark>）

ALU是CPU中执行算术和逻辑运算的核心部件。

**基本功能**：
- 算术运算：加、减、乘、除、增1、减1
- 逻辑运算：与、或、非、异或
- 移位操作：逻辑移位、算术移位、循环移位

**设计要素**：
- 多功能：一个ALU支持多种操作
- 功能选择：通过<mark>控制信号</mark>选择不同功能
- 标志位：<mark>零标志(Z)</mark>、<mark>进位标志(C)</mark>、<mark>溢出标志(V)</mark>、<mark>符号标志(S)</mark>

**简单ALU结构**：
```
输入：A, B（操作数）
控制：F（功能选择码）
输出：Result, Flags（结果和标志位）
```

## 四、重点难点

### 重点（建议高亮）
1. <mark>补码</mark>的表示与运算规则
2. <mark>IEEE 754</mark>浮点数格式（S/E/M、偏置、规格化、NaN/Inf）
3. 定点加减运算及<mark>溢出判断</mark>
4. <mark>ALU</mark>的基本功能与标志位

### 难点
1. 补码运算的<mark>溢出检测</mark>机制
2. 浮点数的<mark>规格化</mark>与<mark>阶码调整</mark>
3. <mark>Booth乘法</mark>算法的原理
4. <mark>加减交替除法</mark>的实现

## 五、教学建议

1. <mark>实例驱动</mark>：通过大量实例演示各种数制转换与运算过程
2. <mark>对比学习</mark>：对比原码、反码、补码的优劣
3. <mark>软件模拟</mark>：使用Logisim设计简单的加法器、ALU
4. <mark>习题训练</mark>：安排足够的练习题巩固运算规则

## 六、易错点检查（对照更正）

1. 认为补码是“把正数也取反+1”（错误）。
   - 对照：正数的补码=其原码；仅负数需“反码+1”。
2. 将浮点数的<mark>隐藏位</mark>写入尾数字段（错误）。
   - 对照：隐藏位不写入M字段，实际值按1.M参与计算。
3. 把<mark>溢出</mark>与<mark>进位</mark>混为一谈（错误）。
   - 对照：溢出检测与最高位进位无必然等价关系，需按方法判定。
4. 忽略<mark>NaN</mark>与<mark>Inf</mark>的编码差异（错误）。
   - 对照：阶码全1时，尾数全0为Inf，非0为NaN。

## 七、课后练习

1. **数制转换**：
   - 将十进制数156转换为二进制、八进制、十六进制
   - 将二进制数10110.101转换为十进制

2. **定点数表示**：
   - 用8位二进制分别表示+25和-25的原码、反码、补码

3. **补码运算**：
   - 计算补码：[+15] + [-20]
   - 判断是否溢出

4. **浮点数表示**：
   - 用IEEE 754单精度格式表示-6.5

5. **设计题**：
   - 设计一个4位补码加法器，画出逻辑电路图

## 八、延伸阅读

- IEEE 754浮点数标准详细文档
- David Goldberg: "What Every Computer Scientist Should Know About Floating-Point Arithmetic"
- 《数字逻辑与计算机组成》相关章节

---

> 总结：本章是计算机组成原理的核心基础，务必熟练掌握数据表示与运算的各个知识点。对于文中用<mark>高亮</mark>标注的术语，建议在你的 PDF 阅读器中建立同名标签或高亮规则，反复检查。