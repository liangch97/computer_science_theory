# 常见问题解答（FAQ）

本文档整理了同学们在学习《计算机组成原理》时常见的疑问与解答。

---

## 第一章：计算机系统概论

### Q1: 冯·诺依曼结构与哈佛结构有什么区别？

**答**：
- **冯·诺依曼结构**：指令和数据存储在同一存储器中，共享同一条总线。优点是结构简单，缺点是存在"冯·诺依曼瓶颈"（指令和数据访问冲突）。
- **哈佛结构**：指令和数据分开存储在两个独立的存储器中，有独立的总线。优点是可以同时访问指令和数据，提高效率；多用于单片机和DSP。

### Q2: 计算机系统的层次结构中，ISA指的是什么？

**答**：
ISA即指令集体系结构（Instruction Set Architecture），是软硬件的接口。它规定了：
- 指令的格式、类型
- 寻址方式
- 数据类型
- 寄存器的数量和用途

ISA向上为软件提供编程接口，向下指导硬件实现。

### Q3: MIPS与CPI有什么区别？

**答**：
- **CPI（Cycles Per Instruction）**：每条指令所需的时钟周期数，是衡量CPU微结构效率的指标。
- **MIPS（Million Instructions Per Second）**：每秒执行百万条指令数，是CPU性能指标之一。

关系：MIPS = 时钟频率（MHz） / CPI

---

## 第二章：数据的表示与运算

### Q4: 原码、反码、补码到底有什么区别？

**答**：

| 编码方式 | 正数表示 | 负数表示 | 零的表示 |
|----------|----------|----------|----------|
| 原码 | 符号位0，数值部分为绝对值 | 符号位1，数值部分为绝对值 | +0（00000000）和-0（10000000） |
| 反码 | 同原码 | 符号位1，数值部分为按位取反 | +0和-0两种 |
| 补码 | 同原码 | 符号位1，数值部分为反码+1 | 仅一个0（00000000） |

**关键点**：补码便于运算，减法可转为加法运算，且零的表示唯一。

### Q5: 为什么补码运算可以把减法转为加法？

**答**：
在补码系统中，负数的补码实际上就是对应正数的"模补数"。利用"模运算"的性质，A - B 等价于 A + (-B)，而(-B)的补码恰好能在加法运算中自动实现借位消除。

示例：
```
计算 5 - 3（8位补码）
[5]补 = 00000101
[3]补 = 00000011
[-3]补 = 11111101

00000101 + 11111101 = 1 00000010
（最高位进位舍弃，结果为 00000010 = +2）
```

### Q6: 浮点数为什么会有精度损失？

**答**：
- 浮点数使用有限的位数表示无限的实数，必然存在表示不精确的情况。
- 例如，0.1在二进制中无法精确表示（会产生无限循环小数），因此只能近似存储。
- 运算过程中的舍入误差会累积，导致最终结果偏差。

### Q7: 如何判断补码运算是否溢出？

**答**：
- **方法1：双符号位法**：正常结果的符号位应为00（正）或11（负）；若为01或10则溢出。
- **方法2：进位判断**：最高位进位C_n与符号位进位C_(n-1)异或，若结果为1则溢出。
- **方法3：符号判断**：两个同符号数相加结果符号改变，则发生溢出。

---

## 第三章：存储系统

### Q8: SRAM和DRAM的区别是什么？

**答**：

| 特性 | SRAM | DRAM |
|------|------|------|
| 存储单元 | 6个晶体管（触发器） | 1个晶体管+1个电容 |
| 速度 | 快（约1-10ns） | 慢（约50-70ns） |
| 容量 | 小 | 大 |
| 成本 | 高 | 低 |
| 刷新需求 | 不需要 | 需要定期刷新 |
| 应用 | CPU内部Cache | 系统主存 |

### Q9: Cache的映射方式有哪些？各有什么特点？

**答**：

1. **直接映射**：
   - 主存块只能映射到Cache的固定位置
   - 实现简单，速度快
   - 冲突概率高，命中率低

2. **全相联映射**：
   - 主存块可以映射到Cache的任意位置
   - 命中率高，冲突少
   - 硬件复杂度高，比较开销大

3. **组相联映射**：
   - 折中方案，主存块映射到固定组内的任意位置
   - 常见配置：2路、4路、8路组相联
   - 平衡了命中率与硬件复杂度

### Q10: LRU替换算法如何实现？

**答**：
- **原理**：替换最近最久未使用（Least Recently Used）的数据块。
- **实现方法**：
  1. **计数器法**：为每个Cache行设置计数器，记录最近访问时间。
  2. **堆栈法**：维护一个访问堆栈，最近访问的在栈顶，最久未访问的在栈底。
  3. **近似LRU**：使用访问位（Reference Bit）简化实现，如Clock算法。

### Q11: 虚拟存储器和Cache有什么区别？

**答**：

| 对比项 | Cache | 虚拟存储器 |
|--------|-------|------------|
| 目的 | 加速内存访问，弥补CPU与主存速度差距 | 扩展地址空间，实现进程隔离 |
| 管理者 | 硬件自动管理 | 操作系统管理 |
| 替换单位 | Cache Line（通常64字节） | 页（通常4KB） |
| 未命中代价 | 较小（几十个时钟周期） | 很大（数百万时钟周期） |

### Q12: TLB是什么？它和页表有什么关系？

**答**：
- **TLB（Translation Lookaside Buffer）**：快表，用于加速虚拟地址到物理地址的转换。
- **关系**：
  - 页表存放在主存中，访问速度慢
  - TLB是页表项的高速缓存，存放最近使用的页表项
  - 访问流程：先查TLB，命中则直接得到物理地址；未命中再查页表

---

## 第四章及后续章节（待补充）

### Q13: CISC和RISC的主要区别是什么？

**答**：
- **CISC（Complex Instruction Set Computer，复杂指令集）**：
  - 指令数量多，功能强大
  - 指令长度不固定
  - 采用微程序控制
  - 代表：x86架构

- **RISC（Reduced Instruction Set Computer，精简指令集）**：
  - 指令数量少，功能简单
  - 指令长度固定
  - 采用硬连线控制
  - 代表：ARM、MIPS、RISC-V

---

## 实验相关问题

### Q14: Logisim是什么？如何使用？

**答**：
Logisim是一款开源的数字电路仿真软件，适合学习数字逻辑和计算机组成原理。
- **下载**：在官网下载或使用Logisim-evolution版本
- **基本使用**：
  1. 从左侧工具栏选择逻辑门、触发器等元件
  2. 拖放到画布上连接电路
  3. 使用输入引脚设置输入，用探针观察输出
  4. 点击"Simulate"菜单启动仿真

### Q15: 如何验证补码运算的正确性？

**答**：
可以编写Python或C语言程序进行验证：

```python
def to_binary(num, bits=8):
    """将整数转为补码表示（指定位数）"""
    if num >= 0:
        return format(num, f'0{bits}b')
    else:
        # 负数：计算补码
        return format((1 << bits) + num, f'0{bits}b')

def add_complement(a, b, bits=8):
    """补码加法"""
    mask = (1 << bits) - 1
    result = (a + b) & mask
    # 判断溢出
    if a >= 0 and b >= 0 and result >= (1 << (bits - 1)):
        print("正溢出")
    elif a < 0 and b < 0 and result < (1 << (bits - 1)):
        print("负溢出")
    return result

# 测试
a = 5
b = -3
print(f"[{a}]补 = {to_binary(a)}")
print(f"[{b}]补 = {to_binary(b)}")
```

---

## 学习方法问题

### Q16: 这门课太难了，怎么学好？

**答**：
- **建立体系**：不要孤立学习每个知识点，要理解它们在整个系统中的位置和作用。
- **多做练习**：通过练习巩固概念，特别是计算题。
- **动手实践**：使用仿真工具搭建电路，加深理解。
- **联系实际**：查看自己电脑的配置（CPU型号、内存大小、Cache参数等），与理论对应。
- **及时复习**：不要积攒问题，遇到不懂的立刻查阅资料或请教老师同学。

### Q17: 如何记住这么多概念？

**答**：
- **理解为主**：优先理解原理，而不是死记硬背。
- **对比记忆**：将相似概念放在一起对比（如原码/反码/补码，SRAM/DRAM）。
- **绘图辅助**：画框图、时序图、地址分解图等辅助记忆。
- **建立联系**：用思维导图将知识点关联起来。

---

## 其他问题

### Q18: 学完这门课对未来有什么用？

**答**：
- 深入理解软件如何在硬件上运行，为学习操作系统、编译原理、嵌入式系统打下基础。
- 优化程序性能时，能从底层角度分析瓶颈（如Cache缺失率、内存访问模式）。
- 为从事硬件设计、芯片开发、系统架构等工作提供必备知识。
- 培养系统思维能力，提高解决复杂问题的能力。

---

**还有其他问题？**

欢迎通过以下方式提问：
- 课堂上直接向老师提问
- 在课程论坛或讨论组发帖
- 给仓库提交Issue

我们会持续更新本FAQ文档。