# 实验指导

本文档提供《计算机组成原理》课程实验的详细指导。实验旨在帮助学生加深对理论知识的理解，培养动手能力。

---

## 实验环境

### 推荐工具

1. **Logisim / Logisim-evolution**
   - 数字电路仿真工具
   - 下载地址：https://github.com/logisim-evolution/logisim-evolution
   - 适用实验：ALU设计、简单CPU设计

2. **编程语言**
   - Python 3.x 或 C语言
   - 适用实验：Cache模拟、页面置换模拟

3. **编辑器**
   - VS Code / PyCharm / Code::Blocks

---

## 实验一：数制转换与数据表示（验证性）

### 实验目的
1. 掌握不同进制之间的转换方法
2. 理解原码、反码、补码的表示规则
3. 掌握IEEE 754浮点数表示方法

### 实验内容

#### 任务1：数制转换
编写程序完成以下功能：
- 十进制与二进制相互转换
- 十进制与十六进制相互转换
- 支持小数转换

**示例代码（Python）**：
```python
def dec_to_bin(n, frac_bits=8):
    """十进制转二进制（支持小数）"""
    if n >= 0:
        sign = 0
        num = n
    else:
        sign = 1
        num = -n
    
    # 整数部分
    integer = int(num)
    int_bin = bin(integer)[2:] if integer > 0 else '0'
    
    # 小数部分
    fraction = num - integer
    frac_bin = ''
    for _ in range(frac_bits):
        fraction *= 2
        bit = int(fraction)
        frac_bin += str(bit)
        fraction -= bit
    
    return f"{sign}{int_bin}.{frac_bin}"

# 测试
print(dec_to_bin(13.5))  # 输出：01101.10000000
```

#### 任务2：补码运算
实现8位补码的加法运算，包括溢出检测。

**提示**：
- 使用位运算模拟8位环境
- 检测符号位变化判断溢出

#### 任务3：浮点数表示
编写函数将十进制数转换为IEEE 754单精度格式。

### 实验报告要求
1. 记录转换过程和结果
2. 分析溢出情况
3. 总结补码与浮点数的特点

---

## 实验二：ALU设计（设计性）

### 实验目的
1. 理解算术逻辑单元（ALU）的功能
2. 掌握加法器、减法器的设计方法
3. 学会使用Logisim进行电路设计与仿真

### 实验内容

#### 任务1：设计1位全加器
- 输入：A、B、Cin（进位输入）
- 输出：S（和）、Cout（进位输出）

**逻辑表达式**：
```
S = A ⊕ B ⊕ Cin
Cout = AB + ACin + BCin
```

#### 任务2：设计4位行波进位加法器
- 将4个全加器级联
- 测试不同输入组合

#### 任务3：设计简单ALU
支持以下功能：
- 000: ADD（加法）
- 001: SUB（减法）
- 010: AND（与）
- 011: OR（或）
- 100: NOT（非）
- 101: XOR（异或）

**框图**：
```
       ┌─────────────────┐
  A ───┤                 │
       │                 │
  B ───┤      ALU        ├─── Result
       │                 │
 F[2:0]┤                 ├─── Zero Flag
       │                 ├─── Carry Flag
       └─────────────────┘
```

### 实验步骤
1. 打开Logisim，新建项目
2. 从工具栏选择逻辑门、多路选择器等元件
3. 连接电路，注意线宽匹配
4. 添加输入引脚和输出探针
5. 运行仿真，测试各种输入

### 实验报告要求
1. 画出电路图（可截图）
2. 列出测试用例及结果
3. 分析设计中的问题与改进方法

---

## 实验三：Cache模拟（综合性）

### 实验目的
1. 深入理解Cache的工作原理
2. 掌握不同映射方式的实现
3. 分析Cache性能指标

### 实验内容

#### 系统配置
- 主存大小：64KB
- Cache大小：1KB
- 块大小：32B
- 映射方式：直接映射 / 4路组相联（可选）

#### 任务1：直接映射Cache模拟
实现Cache的查找、替换功能。

**数据结构**：
```python
class CacheLine:
    def __init__(self):
        self.valid = False      # 有效位
        self.tag = 0            # 标记
        self.data = [0] * 32    # 数据块

class Cache:
    def __init__(self, size=1024, block_size=32):
        self.num_lines = size // block_size
        self.lines = [CacheLine() for _ in range(self.num_lines)]
        self.hit_count = 0
        self.miss_count = 0
    
    def access(self, address):
        # 地址划分：标记 | 行号 | 块内地址
        block_offset = address % 32
        index = (address // 32) % self.num_lines
        tag = address // (32 * self.num_lines)
        
        # 查找Cache
        if self.lines[index].valid and self.lines[index].tag == tag:
            self.hit_count += 1
            return True  # 命中
        else:
            self.miss_count += 1
            # 替换
            self.lines[index].valid = True
            self.lines[index].tag = tag
            return False  # 缺失
    
    def get_hit_rate(self):
        total = self.hit_count + self.miss_count
        return self.hit_count / total if total > 0 else 0
```

#### 任务2：测试与分析
使用以下访问序列测试：
```python
# 序列1：顺序访问
addresses1 = list(range(0, 2048, 4))

# 序列2：跳跃访问
addresses2 = [i * 1024 for i in range(100)]

# 序列3：循环访问
addresses3 = [i % 256 for i in range(1000)]
```

计算每种序列的命中率。

#### 任务3（选做）：实现LRU替换算法
为组相联Cache实现LRU替换策略。

### 实验报告要求
1. 展示代码实现
2. 列出不同访问序列的命中率
3. 分析影响命中率的因素
4. 对比直接映射与组相联的性能

---

## 实验四：页面置换算法模拟（验证性）

### 实验目的
1. 理解虚拟存储器的工作机制
2. 掌握页面置换算法的实现
3. 比较不同算法的性能

### 实验内容

#### 任务1：实现FIFO算法
```python
def fifo(pages, frames):
    """FIFO页面置换算法"""
    memory = []
    page_faults = 0
    
    for page in pages:
        if page not in memory:
            page_faults += 1
            if len(memory) < frames:
                memory.append(page)
            else:
                memory.pop(0)  # 移除最早的
                memory.append(page)
    
    return page_faults
```

#### 任务2：实现LRU算法
```python
def lru(pages, frames):
    """LRU页面置换算法"""
    memory = []
    page_faults = 0
    
    for page in pages:
        if page in memory:
            memory.remove(page)
            memory.append(page)
        else:
            page_faults += 1
            if len(memory) < frames:
                memory.append(page)
            else:
                memory.pop(0)
                memory.append(page)
    
    return page_faults
```

#### 任务3：实现Optimal算法（选做）
```python
def optimal(pages, frames):
    """Optimal页面置换算法"""
    memory = []
    page_faults = 0
    
    for i, page in enumerate(pages):
        if page not in memory:
            page_faults += 1
            if len(memory) < frames:
                memory.append(page)
            else:
                # 找到未来最远使用的页
                future = []
                for p in memory:
                    try:
                        idx = pages[i+1:].index(p)
                        future.append(idx)
                    except ValueError:
                        future.append(float('inf'))
                
                victim = memory[future.index(max(future))]
                memory.remove(victim)
                memory.append(page)
    
    return page_faults
```

#### 任务4：性能对比
测试序列：
```python
pages = [1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5]
frames = 3

print(f"FIFO: {fifo(pages, frames)} 次缺页")
print(f"LRU:  {lru(pages, frames)} 次缺页")
print(f"OPT:  {optimal(pages, frames)} 次缺页")
```

### 实验报告要求
1. 展示代码实现
2. 列出不同算法的缺页次数
3. 分析各算法的优劣
4. 探讨影响缺页率的因素

---

## 实验五：简单CPU设计（综合性/选做）

### 实验目的
1. 综合应用所学知识
2. 理解CPU的组成与工作流程
3. 实现简单的指令执行

### 实验内容

设计一个支持以下指令的简单CPU：
- ADD：加法
- SUB：减法
- LOAD：从内存加载
- STORE：存入内存
- JUMP：无条件跳转

### CPU结构
```
┌─────────┐    ┌──────────┐    ┌─────────┐
│  PC     │───▶│  Memory  │───▶│   IR    │
└─────────┘    └──────────┘    └─────────┘
                     │               │
                     ▼               ▼
                ┌────────┐      ┌─────────┐
                │  MAR   │      │Decoder  │
                └────────┘      └─────────┘
                     │               │
                     ▼               ▼
                ┌────────┐      ┌─────────┐
                │  MDR   │      │   CU    │
                └────────┘      └─────────┘
                     │               │
                     └───────┬───────┘
                             ▼
                        ┌─────────┐
                        │   ALU   │
                        └─────────┘
                             │
                        ┌─────────┐
                        │ Regs    │
                        └─────────┘
```

### 实验步骤
1. 在Logisim中搭建各部件
2. 设计指令格式（如：4位操作码 + 12位地址）
3. 实现指令译码器
4. 连接数据通路
5. 编写测试程序验证功能

### 实验报告要求
1. 详细的设计说明
2. 完整的电路图
3. 测试程序及执行结果
4. 设计心得与改进建议

---

## 实验注意事项

1. **提前预习**：实验前应熟悉相关理论知识
2. **代码规范**：注意代码可读性，添加必要注释
3. **结果验证**：通过多组测试用例验证正确性
4. **及时保存**：定期保存工作进度
5. **独立完成**：鼓励讨论但须独立提交

## 实验评分标准

| 项目 | 分值 |
|------|------|
| 实验结果正确性 | 40% |
| 代码/电路质量 | 30% |
| 实验报告质量 | 20% |
| 创新与拓展 | 10% |

---

**祝实验顺利！遇到问题请及时与老师或助教交流。**